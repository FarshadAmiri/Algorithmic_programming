# -*- coding: utf-8 -*-
"""Recursive_algorithms_benchmark_problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VE_2nHNNXOWHlSUERqtHzMo7gGW7Pdfu
"""

import sys
import math
import time
from decimal import Decimal

print(sys.getrecursionlimit())
sys.setrecursionlimit(10**6)
print(sys.getrecursionlimit())

"""## Factoriel funcion (Comparing recursive programming & Non-recursive programming)"""

# Factoriel funcion (Recursive programming)
# with time complexity of O(n)

def factoriel_rec(n):
  if n==1:
    return n
  else:
    return n * factoriel_rec(n-1)

# Factoriel funcion (Non-Recursive programming - more optimized)
# with time complexity of O(n)

def factoriel_nonrec(n):
  result = 1
  for i in range(1,n+1):
    result *= i
  return result

"""These two implementations have same time complexity order but in terms of memory complexity, the non-recursive function is much more efficient.  """

t1 = time.time()

a = factoriel_rec(10000)
print(str(a)[:1]+'.'+str(a)[1:3]+'e'+str(len(str(a//10))))

print(f'{(time.time()-t1):.6f} seconds')

t1 = time.time()

a = factoriel_nonrec(10000)
print(str(a)[:1]+'.'+str(a)[1:3]+'e'+str(len(str(a//10))))

print(f'{(time.time()-t1):.6f} seconds')

"""## Fibonacci funcion (Comparing recursive programming & Non-recursive programming)"""

# Recursive implementation of fibonacci function
# Time complexity of O(2^n)
# Inefficient memory consumer

def fib_rec(n):
  if n == 1:
    return 1
  if n == 2:
    return 1
  return fib_rec(n-1) + fib_rec(n-2)

# Non-Recursive implementation of fibonacci function (more optimized)
# Time complexity of O(n)
# Most efficient in terms of memory complexity

def fib_nonrec(n):
  fib_dict = {1:1 ,2:1}
  if n <= 3:
    return fib_dict[n-1] + fib_dict[n-2]
  else:
    for i in range(3,n+1):
      fib_dict[i] = fib_dict[i-1] + fib_dict[i-2]
  return fib_dict[n]

"""Here non-recursive programming results in much optimized function as well"""

t1 = time.time()
print(fib_rec(40))
print(f'{(time.time()-t1):.6f} seconds')

t1 = time.time()
a = fib_nonrec(100000)
print(str(a)[:1]+'.'+str(a)[1:3]+'e'+str(len(str(a//10))))
print(f'{(time.time()-t1):.6f} seconds')

"""## Greatest Common Devisor (GCD)"""

x = 1198296
y = 2832102

# Using Standard Library
t1 = time.time()

print(math.gcd(x, y))

print(f'{(time.time()-t1):.6f} seconds')

# Recursive
def gcd(x ,y):
    if y == 0:
        return x
    return gcd(y, x%y)

t1 = time.time()
print(gcd(x, y))
print(f'{(time.time()-t1):.6f} seconds')

"""A recursive program performs much more effiecient in this problem. Here is a non-recursive implementation of this function:


"""

# Non-recursive (There are definitely much more efficinet non-recursive implementations)
def gcd_nonrec(x, y):
  dvd_x = set()
  dvd_y = set()
  for i in range(1,x):
    if x%i == 0:
      dvd_x.update([i,int(x/i)])
  for i in range(1,y):
    if y%i == 0:
      dvd_y.update([i,int(y/i)])
  for i in sorted(dvd_x, reverse = True):
    if i in dvd_y:
      return (i)

t1 = time.time()
print(gcd_nonrec(x, y))
print(f'{(time.time()-t1):.6f} seconds')

